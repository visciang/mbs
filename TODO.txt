cache:
- possibility to cache a toolchain step (for example to cache deps)
- custom containter cache dir?

deploy:
- deploy state (to deploy only if needed, we should multi environment deployments)

execution:
- pass e json env variable to toolchains run with all the MBS_* vars and metadata
  (should be a better / more flexible contract)
- docker-compose support
- podman / docker executor choice ?
- System.cmd replacement (occhio agli zombi), ma serve se stacchiamo toolchain exec con docker?
  --init anche su toolchain "docker run"?

manifest:
- .mbs-config.json sezione file_profiles
- lookup .mbs-config.json from the current directory up (like asdf)
- currently we apply a recursive glob discover of manifests, introduce a components manifest to explicitly list them (usefull also to add/remove a component from the run)
  it scales well in big repository with lot's of untracked file (-> node_modules)
- Config option use .gitignore to filter job.files

misc
- docker image namespacing
- docker build --rm and intermediate container ... (docker rmi $(docker images -f "dangling=true" -q))
- git://... dependencies

cli
- pass secrets in mbs
- cache command (purge | size | info ... ?)
- Job logs on files option?

sandboxing:
- Sandboxing execution (every buld should se only its file (the input one) and dependencies artifact)
  no FS sharing with the host => no build tmp files left around, only the targets file should be extract and copied in the cache

support / doc
- Documentation
- (npm 7 workspaces) https://dev.to/limal/simplify-your-monorepo-with-npm-7-workspaces-5gmj
- more examples
  BUILD:
    - NodeJS / Deno
    - Ruby
    - Elixir
    - Rust
    https://medium.com/underdog-io-engineering/vendoring-python-dependencies-with-pip-b9eb6078b9c0
  DEPLOY:
    - fly

plugins
  - remote cache (docker / files) => push only if --push flag provided
  - HTTP
  - AWS
  - DOCKER

DEV:
- functional tests
